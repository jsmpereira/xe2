#+title: Void Mission: a sci-fi action roguelike game in Common Lisp
#+author: David T. O'Toole <dto@gnu.org> <dto1138@gmail.com>

* Header

#+source: copyright-notice
#+begin_src lisp
;; Copyright (C) 2010  David O'Toole

;; Author: David O'Toole <dto@gnu.org>
;; Keywords: 

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <http://www.gnu.org/licenses/>.
#+end_src

#+tags: Interface Player Structure Environment Controls Combat Enemies Planning Story
#+property: tangle no
#+property: cache no
#+property: session yes
#+property: results silent
#+property: no-expand yes
#+property: noweb yes
#+startup: showall

#+source: xe2-lisp-file
#+begin_src lisp :tangle yes
<<copyright-notice>>
<<package-definition>>
<<settings>>
<<global-objects>>
<<keybindings>>
<<physics-function>>
<<things>>
<<cloud-world>>
<<player-definition>>
<<game-definition>>
#+end_src

#+source: package-definition
#+begin_src lisp 
  (defpackage :void
    (:use :xe2 :common-lisp)
    (:export physics))
  
  (in-package :void)
#+end_src

#+source: global-objects
#+begin_src lisp
  (defvar *form*)
  (defvar *pager*)
  (defvar *narrator*)
  (defvar *prompt*)
  (defvar *player*)
  (defvar *viewport*)
#+end_src

#+source: physics-function
#+begin_src lisp
  (defun physics (&rest ignore)
    (when *world* [run-cpu-phase *world* t]))
#+end_src

#+source: settings
#+begin_src lisp
  (defparameter *timestep* 20)
  (defparameter *grid-size* 16)
  (defparameter *address* '(=cloud=))
  (defparameter *width* 1280)
  (defparameter *height* 720)
#+end_src

#+source: cloud-world
#+begin_src lisp
  (defcell vaccuum 
    (tile :initform "vaccuum"))
  
  (defcell red-plasma
    (tile :initform "red-plasma"))
  
  (defcell blue-plasma
    (tile :initform "blue-plasma"))
  
  (defworld cloud
    (name :initform "DVO UV Shield Cloud")
    (scale :initform '(50 m))
    (edge-condition :initform :block)
    (background :initform "cloud")
    (ambient-light :initform :total)
    (description :initform "foo"))
    
  (define-method begin-ambient-loop cloud ()
    (play-music "passageway" :loop t))
    
  (define-method drop-plasma cloud
      (&optional &key (object =red-plasma=)
                 distance 
                 (row 0) (column 0)
                 (graininess 0.3)
                 (density 100)
                 (cutoff 0))
      (clon:with-field-values (height width) self
        (let* ((h0 (or distance height))
               (w0 (or distance width))
               (r0 (- row (truncate (/ h0 2))))
               (c0 (- column (truncate (/ w0 2))))
               (plasma (xe2:render-plasma h0 w0 :graininess graininess))
               (value nil))
          (dotimes (i h0)
            (dotimes (j w0)
              (setf value (aref plasma i j))
              (when (< cutoff value)
                (when (or (null distance)
                          (< (distance (+ j r0) (+ c0 i) row column) distance))
                  (percent-of-time density
                    [drop-cell self (clone object) (+ r0 i) (+ c0 j) :no-collisions t]))))))))
    
  (define-method generate cloud (&key (height 100)
                                      (width 100)
                                      (protostars 30)
                                      (sequence-number (genseq)))
    (setf <height> height <width> width)
    [create-default-grid self]
    ;; (dotimes (i width)
    ;;   (dotimes (j height)
    ;;     [drop-cell self (clone (if (zerop (random 7))
    ;;                                =vaccuum= 
    ;;                                =blue-plasma=))
    ;;                i j]))
    ;;    [drop-plasma self]
    ;; (dotimes (i protostars)
    ;;   (let ((r (random height))
    ;;      (c (random width)))
    ;;     [drop-plasma self :object =protogas= :distance 12 :row r :column c :graininess 0.3]
    ;;     [drop-plasma self :object =crystal= :density 7 :distance 16 :row r :column c :graininess 0.3]
      ;;     [drop-cell self (clone =protostar=) r c]))
    [drop-cell self (clone =launchpad=) 88 60])
#+end_src

#+source: player-definition
#+begin_src lisp 
  (defparameter *react-shield-time* 30)
  
  (defparameter *energy-recovery-interval* 200)
  
  (defcell agent 
    (tile :initform "agent-north")
    (firing :initform nil)
    (items :initform nil)
    (tail-length :initform 3)
    (direction :initform :north)
    (last-direction :initform :north :documentation "Last direction actually moved.")
    (dead :initform nil)
    (last-turn-moved :initform 0)
    (team :initform :player)
    (call-clock :initform 0)
    (call-interval :initform 7)
    (hit-points :initform (make-stat :base 20 :min 0 :max 20))
    (energy :initform (make-stat :base 80 :min 0 :max 80))
    (oxygen :initform (make-stat :base 80 :min 0 :max 80))
    (movement-cost :initform (make-stat :base 10))
    (speed :initform (make-stat :base 10 :min 0 :max 10))
    (hearing-range :initform 25)
    (stepping :initform t)
    (light-radius :initform 7)
    (react-shield-clock :initform 0)
    (energy-clock :initform *energy-recovery-interval*)
    (categories :initform '(:actor :obstacle :player :target :container :light-source)))
  
  (define-method loadout agent ()
    (push (clone =buster-defun=) <items>)
    [emote self '((("I'd better get moving."))
                  (("Use the arrow keys (or numpad)"))
                  (("to move, and SHIFT to fire.")))])
  
  (define-method start agent ())
  
  (define-method expend-energy agent (points)
    (if (>= [stat-value self :energy] points)
        (prog1 t [stat-effect self :energy (- points)])
        (prog1 nil 
          [say self "Insufficient energy."]
          [play-sample self "error"])))
  
  (define-method damage agent (points)
    (if (zerop <react-shield-clock>)
        (labels ((do-circle (image)
                   (prog1 t
                     (multiple-value-bind (x y) 
                         [image-coordinates self]
                       (let ((x0 (+ x 8))
                             (y0 (+ y 8)))
                         (draw-circle x0 y0 25 :destination image)
                         (draw-circle x0 y0 30 :destination image)
                         (draw-circle x0 y0 35 :destination image)
                         (draw-circle x0 y0 40 :destination image))))))
          (setf <react-shield-clock> *react-shield-time*)
          [play-sample self "shield-warning"]
          [>>add-overlay :viewport #'do-circle]
          [parent>>damage self points])
        [play-sample self "ice"]))
    
  (define-method pause agent ()
    [pause *world*])
  
  (defparameter *agent-tiles* '(:north "agent-north"
                               :south "agent-south"
                               :east "agent-east"
                               :west "agent-west"))
  
  (define-method aim agent (direction)
    (setf <direction> direction)
    (setf <tile> (getf *agent-tiles* direction)))
  
  (define-method move agent (&optional direction)
    (unless <dead>
      (let ((phase (field-value :phase-number *world*))
            (dir (or direction <direction>)))
        (unless (= <last-turn-moved> phase)
          (setf <last-turn-moved> phase)
          [aim self dir]
          (when [parent>>move self dir]
            (setf <last-direction> dir))))))
  
  (define-method space-at-head agent ()
    (values <row> <column>))
  
  (define-method category-at-head agent (category)
    (multiple-value-bind (row column) 
        [space-at-head self]
      [category-at-p *world* row column category]))
  
  (define-method item-at-head agent ()
    [category-at-head self :item])
  
  (define-method obstacle-at-head agent ()
    [category-at-head self :obstacle])
    
  (define-method push agent () 
    (unless <dead>
      (if (= (length <items>) <tail-length>)
          (progn 
            [say self "Maximum capacity reached."]
            [play-sample self "error"])
          (let ((item [item-at-head self]))
            (if item
                (progn (setf <items> (append <items> (list item)))
                       [play-sample self "doorbell"]
                       [print-items self]
                       [delete-from-world item])
                [say self "Nothing to push."])))))
          
  (define-method pop agent ()
    (unless (or <dead> [in-overworld self])
      (clon:with-fields (items) self
        (multiple-value-bind (row column)
            [space-at-head self]
          (let ((item (car items)))
            (if (clon:object-p item)
                (progn (setf items (delete item items))
                       [play-sample self "doorbell2"]
                       [drop-cell *world* item row column]
                       [print-items self])
                [say self "Nothing to drop."]))))))
    
  (define-method act agent ()
    (unless <dead>
      (let ((gateway [category-at-p *world* <row> <column> :gateway]))
        (if (clon:object-p gateway)
            [activate gateway]
            (cond ([category-at-head self :action]
                   [do-action [category-at-head self :action]])
                  ([category-at-head self :item]
                   [push self])
                  (t 
                   [play-sample self "error"]
                   [say self "Nothing to do here."]))))))
  
  (define-method expend-item agent ()
    (pop <items>)
    [print-items self])
  
  (define-method rotate agent () 
    (unless <dead>
      (clon:with-fields (items) self
        (if items
            (let ((tail (car (last items)))
                  (newlist (butlast items)))
              [play-sample self "doorbell3"]
              (setf items (cons tail newlist))
              [print-items self])
            (progn 
              [play-sample self "error"]
              [say self "Cannot rotate empty list."])))))
  
  (define-method call agent (&optional direction)
    (unless <dead>
      (when (zerop <call-clock>)
        (when direction
          [aim self direction])
        (let ((item (car <items>)))
          (if (and item [in-category item :item]
                   (clon:has-method :call item))
              (progn 
                (when [expend-energy self (field-value :energy-cost item)]
                  [call item self]
                  (setf <call-clock> (field-value :call-interval item))))
              [say self "Cannot call."])))))
  
  (define-method print-items agent ()
    (labels ((print-item (item)
               [>>print :narrator nil :image (field-value :tile item)]
               [>>print :narrator "  "]
               [>>print :narrator (get-some-object-name item)]
               [>>print :narrator "  "])
             (newline ()
               [>>newline :narrator]))
      [>>print :narrator " ITEMS: "]
      (dolist (item <items>)
        (print-item item))
      (newline)))
        
  (define-method run agent () 
  ;;  [update-tiles self]
    (when (plusp <call-clock>)
      (decf <call-clock>))
    (when (plusp <energy-clock>)
      (decf <energy-clock>))
    (when (zerop <energy-clock>)
      (setf <energy-clock> *energy-recovery-interval*)
      [stat-effect self :energy 1])
    (when (plusp <react-shield-clock>)
      (decf <react-shield-clock>)
      [play-sample self "shield-sound"]
      (labels ((do-circle (image)
                 (prog1 t
                   (multiple-value-bind (x y) 
                       [image-coordinates self]
                     (let ((x0 (+ x 8))
                           (y0 (+ y 8)))
                       (draw-circle x0 y0 (+ 25 (random 3)) :destination image :color (car (one-of (list ".cyan" ".hot pink" ".white"))))
                       (draw-circle x0 y0 (+ 30 (random 3))  :destination image :color (car (one-of (list ".cyan" ".hot pink" ".white")))))))))
        [>>add-overlay :viewport #'do-circle]))
    (when (or (keyboard-modifier-down-p :lshift)
              (keyboard-modifier-down-p :rshift))
      [call self <direction>])
    (dolist (item <items>)
      (when [in-category item :actor]
        [run item])))
  
  (define-method quit agent ()
    (xe2:quit :shutdown))
  
  (define-method do-exit agent ()
    [exit *universe*])
  
  (define-method exit agent ()
    (dolist (segment <segments>)
      [die segment])
    (setf <segments> nil))
  
  (define-method die agent ()
        (unless <dead>
      (setf <tile> "agent-disabled")
      (dolist (segment <segments>)
        [die segment])
      (setf <segments> nil)
      (dotimes (n 30)
        [drop self (clone =explosion=)])
      [play-sample self "gameover"]
      [say self "You died. Press escape to reset."]
      (setf <dead> t)))
  
  (define-method restart agent ()
    (let ((agent (clone =agent=)))
      [say self "Restarting CONS..."]
      (halt-sample t)
      (setf *player* agent)
      [destroy *universe*]
      [set-player *universe* agent]
  ;;    [set-prompt *form* agent]
      [set-character *status* agent]
      [play *universe*
            :address (list '=zeta-x= :sequence-number (genseq))]
      [loadout agent]))
  
  ;;; Player upgrade
  
  (defcell tail-defun 
    (name :initform "Body Extender Segment")
    (tile :initform "tail-defun")
    (call-interval :initform 20)
    (energy-cost :initform 0)
    (categories :initform '(:item :target :defun)))
  
  (define-method call tail-defun (caller)
    [upgrade caller]
    [expend-item caller])
#+end_src

#+source: game-definition
#+begin_src lisp 
  (defgame :void
      (:title "Void Mission"
       :description "A sci-fi roguelike game in Common Lisp."
       :creator "David T. O'Toole <dto@gnu.org>"
       :screen-width *width*
       :screen-height *height*
       :timestep *timestep*
       :physics-function #'void:physics)
    ;; create some objects
    (setf *prompt* (clone =void-prompt=))
    (setf *universe* (clone =universe=))
    (setf *player* (clone =agent=))
    (setf *narrator* (clone =narrator=))
    [set-player *universe* *player*]
    (setf *viewport* (clone =viewport=))
    ;; configure the view
    [resize *viewport* :height *height* :width *width*]
    [move *viewport* :x 0 :y 0]
    [set-origin *viewport* :x 0 :y 0 
                :height (truncate (/ *height* *grid-size*))
                :width (truncate (/ *width* *grid-size*))]
    [resize *prompt* :height 20 :width 100]
    [move *prompt* :x 0 :y 0]
    [hide *prompt*]
    [resize *narrator* :height 80 :width *width*]
    [move *narrator* :x 0 :y (- *height* 80)]
    [set-verbosity *narrator* 0]
    [install-keybindings *prompt*]
    (xe2:install-widgets *prompt* *viewport*)
    (xe2:enable-classic-key-repeat 100 60)
    ;; now play!
    [play *universe*
          :player *player*
          :narrator *narrator*
          :address *address*
          :prompt *prompt*
          :viewport *viewport*])
#+end_src
    
* Overview

"Void Mission" is a sci-fi action roguelike divided into three
episodes. The action takes place in a 2-D pixeled future in which you
fly a transforming humanoid/jet suit in both exterior space and
interior environments while firing projectile and/or energy weapons at
enemies and simultaneously avoiding their fire. The story is largely
told through text, represented in the game as data files, emails, or
voice communications with a non-player character. Gameplay is tied
into the story with missions that require balancing combat with
exploration and puzzle solving.

Void Mission's game play is that of a rogue-like with simplified
controls. Only the four cardinal directions are available for movement
and firing, and the player can only carry or use a few (i.e. between 1
and 5) items at a time. The player also has fewer stats than in a
typical roguelike, but various upgrades make sure that character
development is still central.

* Controls					       :Controls:

  - Arrow keys (or numeric keypad) for player movement.
  - Shift-arrow for activating the selected inventory item.
    If this is a gun for example, you fire in that direction.
  - Z to change the selected inventory item
  - X for picking up items, activating switches, and so on.
  - C to drop the selected inventory item

** Default keybindings

The CALL method is not actually triggered by the shift-direction
keybindings. Instead, to obtain satisfactory behavior, the shift key
is polled every physics timestep. See the player's RUN method.

#+source: keybindings
#+begin_src lisp
  (defparameter *numpad-keybindings* 
    '(("KP8" nil "move :north .")
      ("KP4" nil "move :west .")
      ("KP6" nil "move :east .")
      ("KP2" nil "move :south .")
      ;; 
      ("UP" nil "move :north .")
      ("LEFT" nil "move :west .")
      ("RIGHT" nil "move :east .")
      ("DOWN" nil "move :south .")
      ;; 
      ("KP8" (:shift) "move :north .")
      ("KP4" (:shift) "move :west .")
      ("KP6" (:shift) "move :east .")
      ("KP2" (:shift) "move :south .")
      ;; 
      ("UP" (:shift) "move :north .")
      ("LEFT" (:shift) "move :west .")
      ("RIGHT" (:shift) "move :east .")
      ("DOWN" (:shift) "move :south .")))
  
  (defparameter *qwerty-keybindings*
    (append *numpad-keybindings*
            '(("K" nil "move :north .")
              ("H" nil "move :west .")
              ("L" nil "move :east .")
              ("J" nil "move :south .")
              ;;
              ("K" (:shift) "move :north .")
              ("H" (:shift) "move :west .")
              ("L" (:shift) "move :east .")
              ("J" (:shift) "move :south .")
              ;;
              ("Z" nil "rotate .")
              ("X" nil "act .")
              ("C" nil "pop .")
              ("0" (:control) "do-exit .")
              ;;
              ("P" (:control) "pause .")
              ("PAUSE" nil "pause .")
              ("ESCAPE" nil "restart .")
              ("Q" (:control) "quit ."))))
    
  (define-prototype void-prompt (:parent xe2:=prompt=))
  
  (define-method install-keybindings void-prompt ()
  (message "installing keybindings...")
    (dolist (k *qwerty-keybindings*)
      (apply #'bind-key-to-prompt-insertion self k)))
  
  ;; (define-method handle-key void-prompt (keylist)
  ;;   (message "handling ~S" keylist)
  ;;   [parent>>handle-key self keylist])
  
  ;; (define-method install-keybindings void-prompt ()
  ;;   (let ((keys (ecase xe2:*user-keyboard-layout* 
  ;;              (:qwerty *qwerty-keybindings*)
  ;;              (:alternate-qwerty *alternate-qwerty-keybindings*)
  ;;              (:dvorak *dvorak-keybindings*))))
  ;;     (dolist (k keys)
  ;;       (apply #'bind-key-to-prompt-insertion self k))))
#+end_src

** Joystick control

* The player 						 :Player:

The player is a human male who spends the entire game inside an Olvac
mimetic-plasteel exosuit, and can move freely between
interior and exterior scenes. This suit has two modes: humanoid mode,
in which the suit acts as an exoskeleton for exploring human-scale
environments, and a fighter mode with high-speed jetpack and wide,
micro-thin plasteel wings for space travel and combat.

The suit's energy shield is its sole defense; when SP (shield points)
drop to zero, you die. 

Character development comes in the form of upgrades such as additional
inventory slots, increased firing power, hit points, new weapons, and
so on.

*** TODO Draw exosuit 16x16 graphics (tweak Blast Tactics voyager stuff)

 file:gun.png

** TODO Design and write about upgrade system

* Mission structure 				      :Structure:

Gameplay is mission-based, with one mission leading to others in a
branching fashion. Each mission is self contained, and the player and
his inventory are all that survive a mission.

** TODO Define lisp mission structure

 - http://norvig.com/ltd/test/micro-tale-spin.lisp

* The game world 				    :Environment:

Each mission takes place across one or more grid-based XE2 maps.

* Combat system						 :Combat:

The player can fire various bullets and beams at enemies, destructible
objects, and other targets. Bullets take time to travel to a target;
beams (usually energy weapons) are instantaneous point-to-point.

Energy weapons use up the energy points (EN) meter, and cannot fire
without sufficient EN. You can restore EN with Energy packs, or by
visiting an energy recharge station.

** TODO Import energy packs
** TODO Create recharge station

Shell based weapons have limited ammo, but do not require energy to
fire.

Some enemies are shielded from energy attacks, and require shell-based
weapons to defeat.

Various kinds of bombs and mines also exist. 

** TODO Import kickable bombs from CONS
** TODO Import seeking gravmines from BT
** TODO Create sticky bombs
** TODO Create grenade weapon, area effect explosion

* Things

#+source: things
#+begin_src lisp
(in-package :void)

(defun same-team (obj1 obj2)
  (eq (field-value :team obj1)
      (field-value :team obj2)))

;;; Glittering flash gives clues on locations of explosions/damage

(defcell flash 
  (clock :initform 2)
  (tile :initform "flash-1")
  (categories :initform '(:actor))
  (speed :initform (make-stat :base 1)))

(define-method run flash ()
  [expend-action-points self 10]
  (case <clock>
    (1 (setf <tile> "flash-2"))
    (0 [>>die self]))
  (decf <clock>))

;;; Sparkle is a bigger but faster flash.

(defcell sparkle 
  (clock :initform 1)
  (tile :initform "sparkle")
  (categories :initform '(:actor))
  (speed :initform (make-stat :base 1)))

(define-method run sparkle ()
  [expend-action-points self 20]
  (case <clock>
    (1 (setf <tile> "sparkle"))
    (0 [die self]))
  (decf <clock>))

;;; An explosion.

(defcell explosion 
  (name :initform "Explosion")
  (categories :initform '(:actor :target))
  (tile :initform "explosion")
  (speed :initform (make-stat :base 4))
  (damage-per-turn :initform 10)
  (clock :initform 6))

(define-method run explosion ()
  (if (zerop <clock>)
      [die self]
      (progn
	(setf <tile> (car (one-of '("explosion" "explosion2"))))
	(percent-of-time 30 [play-sample self "crunch"])
	(decf <clock>)
	(percent-of-time 80 [move self (random-direction)])
	[expend-action-points self 10]
	(xe2:do-cells (cell [cells-at *world* <row> <column>])
	  [damage cell <damage-per-turn>]))))

;;; Particle gun

(defcell buster-particle 
  (tile :initform "blueparticle")
  (movement-cost :initform (make-stat :base 0))
  (speed :initform (make-stat :base 5 :min 0 :max 10))
  (team :initform :player)
  (categories :initform '(:actor :particle :target))
  (direction :initform :north))

(define-method initialize buster-particle (direction)
  (setf <direction> direction))

(define-method run buster-particle ()
  (multiple-value-bind (r c) (step-in-direction <row> <column> <direction>)
    (let ((obs [obstacle-at-p *world* r c]))
      (if obs
	  (cond ((eq t obs)
		 ;; out of bounds.
		 [die self])
		((clon:object-p obs)
		 ;; hit it
		 (let ((thing (or [category-at-p *world* r c :target] obs)))
		   (if (null thing)
		       [move self <direction>]
		       (progn 
			 (when [in-category thing :puck]
			   [kick thing <direction>])
			 (when (and (clon:has-method :hit thing)
				    (not (same-team self thing)))
			   [drop self (clone =flash=)]
			   [hit thing])
			 [die self])))))
	  [move self <direction>]))))

(defcell buster-defun
  (name :initform "Buster gun")
  (description :initform 
"The BUSTER program fires a relatively weak particle weapon when activated.
However, ammunition is unlimited, making BUSTER an old standby.")
  (tile :initform "buster")
  (energy-cost :initform 0)
  (call-interval :initform 7)
  (clock :initform 0)
  (categories :initform '(:item :target :defun)))

(define-method call buster-defun (caller)
  (clon:with-field-values (direction row column) caller
    [play-sample caller "fire"]
    [drop-cell *world* (clone =buster-particle= direction) row column]))

;;; A bomb with countdown display.

(defvar *bomb-tiles* '("bomb-1" "bomb-2" "bomb-3" "bomb-4"))

(defun bomb-tile (n)
  (nth (truncate (/ (- n 1) 30)) *bomb-tiles*))

(defcell bomb 
  (categories :initform '(:actor :puck :target :obstacle))
  (clock :initform 120)
  (team :initform :enemy)
  (direction :initform nil)
  (speed :initform (make-stat :base 1))
  (tile :initform (bomb-tile 4)))

(define-method kick bomb (direction)
  (setf <direction> direction))

(define-method run bomb () 
  (clon:with-fields (clock direction) self	       
    (if (zerop clock) 
	[explode self]
	(progn 
	  (when (and direction (evenp clock))
	    (multiple-value-bind (r c) 
		(step-in-direction <row> <column> direction)
	      (if [obstacle-at-p *world* r c]
		  (setf direction nil)
		  [move-cell *world* self r c])))
	  (when (zerop (mod clock 30))
	    (setf <tile> (bomb-tile clock))
	    [play-sample self "countdown"]
	    (dotimes (n 10)
	      [drop self (clone =particle=)]))
	  (decf clock)))))

(define-method explode bomb ()  
  (labels ((boom (r c &optional (probability 70))
	     (prog1 nil
;;	       (message "BOOM ~S" (list r c))
	       (when (and (< (random 100) probability)
			  [in-bounds-p *world* r c]
			  [can-see-* self r c :barrier])
		 [drop-cell *world* (clone =explosion=) r c :no-collisions nil])))
	   (damage (r c &optional (probability 100))
	     (prog1 nil
;;	       (message "DAMAGE ~S" (list r c))
	       (when (and (< (random 100) probability)
			  [in-bounds-p *world* r c]
			  [can-see-* self r c :obstacle])
		 (do-cells (cell [cells-at *world* r c])
		   (when (clon:has-method :damage cell)
		     [damage cell 16])
		   (when (clon:has-method :hit cell)
		     [hit cell]))))))
    ;; definitely damage everything in radius
    (trace-rectangle #'damage
		     (- <row> 2) 
		     (- <column> 2) 
		     5 5 :fill)
    ;; immediately adjacent explosions
    (dolist (dir xe2:*compass-directions*)
      (multiple-value-bind (r c)
	  (step-in-direction <row> <column> dir)
	(boom r c 100)))
    ;; randomly sprinkle some fire around edges
    (trace-rectangle #'boom 
		     (- <row> 2) 
		     (- <column> 2) 
		     5 5)
    (trace-rectangle #'boom 
		     (- <row> 3) 
		     (- <column> 3) 
		     7 7)
    ;; ever-present sparkles
    (dotimes (n (+ 10 (random 10)))
      [drop self (clone =plasma=)])
    ;; circular flash
    (labels ((do-circle (image)
	       (prog1 t
		 (multiple-value-bind (x y) 
		     [screen-coordinates self]
		   (let ((x0 (+ x 8))
			 (y0 (+ y 8)))
		     (draw-circle x0 y0 40 :destination image)
		     (draw-circle x0 y0 35 :destination image))))))
      [>>add-overlay :viewport #'do-circle])
    [die self]))

(defcell bomb-defun
  (name :initform "Bomb")
  (description :initform "This single-use BOMB program drops a timed explosive device.")
  (tile :initform "bomb-ammo")
  (energy-cost :initform 5)
  (call-interval :initform 20)
  (categories :initform '(:item :target :defun)))

(define-method call bomb-defun (caller)
  (clon:with-field-values (direction row column) caller
    (multiple-value-bind (r c) (step-in-direction row column direction)
      (if [obstacle-at-p *world* r c]
	  (progn [play-sample self "error"]
		 [say self "Cannot drop bomb here."])
	  (progn [play-sample caller "fire"]
		 [drop-cell *world* (clone =bomb=) r c]
		 [expend-item caller])))))

;;; Bomb cannon

(defcell bomb-cannon
  (categories :initform '(:item :weapon :equipment))
  (attack-cost :initform (make-stat :base 5))
  (weight :initform 3000)
  (equip-for :initform '(:right-bay :robotic-arm)))

(define-method activate bomb-cannon ()
  ;; leave bomb on top of ship
  (clon:with-field-values (row column) <equipper>
    [drop-cell *world* (clone =bomb=) row column]))

(define-method fire bomb-cannon (direction)
  (clon:with-field-values (last-direction row column) <equipper>
    (multiple-value-bind (r c) 
	(step-in-direction row column direction)
      [drop-cell *world* (clone =bomb=) r c :no-collisions t])))

;;; The exploding mine

(defcell mine 
  (name :initform "Proximity mine")
  (categories :initform '(:item :target :actor :hidden))
  (tile :initform "mine")
  (description :initform "If you get near it, it will probably explode."))

(defvar *mine-warning-sensitivity* 5)
(defvar *mine-explosion-sensitivity* 3)

(define-method run mine ()
  (let ((distance [distance-to-player *world* <row> <column>]))
    (if (< distance *mine-warning-sensitivity*)
	(progn
	  (when (string= <tile> "mine")
	    [>>say :narrator "You see a mine nearby!"])
	  (setf <tile> "mine-warn")
	  (when (< distance *mine-explosion-sensitivity*)
	    (when (< (random 8) 1)
	      [explode self])))
	(setf <tile> "mine"))))

(define-method explode mine ()
  (labels ((boom (r c &optional (probability 50))
	     (prog1 nil
	       (when (and (< (random 100) probability)
			  [in-bounds-p *world* r c])
		 [drop-cell *world* (clone =explosion=) r c :no-collisions nil]))))
    (dolist (dir xe2:*compass-directions*)
      (multiple-value-bind (r c)
	  (step-in-direction <row> <column> dir)
	(boom r c 100)))
    ;; randomly sprinkle some fire around edges
    (trace-rectangle #'boom 
		     (- <row> 2) 
		     (- <column> 2) 
		     5 5)
    [die self]))

(define-method step mine (stepper)
  (when [is-player stepper]	      
    [explode self]))

(define-method damage mine (damage-points)
  (declare (ignore damage-points))
  [explode self])

;;; Muon particles, trails, and pistols

(defvar *muon-tiles* '(:north "muon-north"
		       :south "muon-south"
		       :east "muon-east"
		       :west "muon-west"
		       :northeast "muon-northeast"
		       :southeast "muon-southeast"
		       :southwest "muon-southwest"
		       :northwest "muon-northwest"))

(defvar *trail-middle-tiles* '(:north "bullet-trail-middle-north"
			       :south "bullet-trail-middle-south"
			       :east "bullet-trail-middle-east"
			       :west "bullet-trail-middle-west"
			       :northeast "bullet-trail-middle-northeast"
			       :southeast "bullet-trail-middle-southeast"
			       :southwest "bullet-trail-middle-southwest"
			       :northwest "bullet-trail-middle-northwest"))

(defvar *trail-end-tiles* '(:north "bullet-trail-end-north"
			       :south "bullet-trail-end-south"
			       :east "bullet-trail-end-east"
			       :west "bullet-trail-end-west"
			       :northeast "bullet-trail-end-northeast"
			       :southeast "bullet-trail-end-southeast"
			       :southwest "bullet-trail-end-southwest"
			       :northwest "bullet-trail-end-northwest"))

(defvar *trail-tile-map* (list *trail-end-tiles* *trail-middle-tiles* *trail-middle-tiles*))

(defcell muon-trail
  (categories :initform '(:actor))
  (clock :initform 2)
  (speed :initform (make-stat :base 10))
  (default-cost :initform (make-stat :base 10))
  (tile :initform ".gear")
  (direction :initform :north))

(define-method orient muon-trail (direction)
  (setf <direction> direction)
  (setf <tile> (getf *trail-middle-tiles* direction)))

(define-method run muon-trail ()
  (setf <tile> (getf (nth <clock> *trail-tile-map*)
		     <direction>))
  [expend-default-action-points self]
  (decf <clock>)
  (when (minusp <clock>)
    [die self]))

;;; Basic muon particle

(defcell muon-particle 
  (categories :initform '(:actor :muon :target))
  (speed :initform (make-stat :base 22))
  (default-cost :initform (make-stat :base 3))
  (attack-power :initform 5)
  (tile :initform "muon")
  (firing-sound :initform "dtmf2")
  (direction :initform :here)
  (clock :initform 12))

(define-method initialize muon-particle (&key attack-power)
  (when attack-power
    (setf <attack-power> attack-power)))

(define-method drop-trail muon-particle (direction)
  (let ((trail (clone =muon-trail=)))
    [orient trail direction]
    [drop self trail]))

(define-method find-target muon-particle ()
  (let ((target [category-in-direction-p *world* 
					 <row> <column> <direction>
					 '(:obstacle :target)]))
    (if target
	(progn
	  [>>move self <direction>]
	  [>>expend-default-action-points self]
	  [>>drop target (clone =flash=)]
	  ;;[>>push target <direction>]
	  [>>damage target <attack-power>]
	  [>>die self])
	(multiple-value-bind (r c) 
	    (step-in-direction <row> <column> <direction>)
	  (if (not (array-in-bounds-p (field-value :grid *world*) r c))
	      [die self]
	      (progn [drop-trail self <direction>]
		     [>>move self <direction>]))))))

(define-method step muon-particle (stepper)
  [damage stepper <attack-power>]
  [die self])
  
(define-method update-tile muon-particle ()
  (setf <tile> (getf *muon-tiles* <direction>)))

(define-method run muon-particle ()
  [update-tile self]
  [find-target self]
  (decf <clock>)
  (when (zerop <clock>)
    [>>die self]))

(define-method impel muon-particle (direction)
  (assert (member direction *compass-directions*))
  (setf <direction> direction)
  ;; don't hit the player
  ;;  [move self direction]
  [play-sample self <firing-sound>]
  [find-target self])

;;; Beta-muons

(define-prototype beta-muon (:parent =muon-particle=)
  (speed :initform (make-stat :base 24))
  (attack-power :initform 8)
  (firing-sound :initform "dtmf3")
  (tile :initform "beta-muon")
  (clock :initform 15))
  
(defvar *beta-muon-tiles* '(:north "beta-muon-north"
			    :south "beta-muon-south"
			    :east "beta-muon-east"
			    :west "beta-muon-west"
			    :northeast "beta-muon-northeast"
			    :southeast "beta-muon-southeast"
			    :southwest "beta-muon-southwest"
			    :northwest "beta-muon-northwest"))

(define-method update-tile beta-muon ()
  (setf <tile> (getf *beta-muon-tiles* <direction>)))

;;; Muon cannon

(defcell muon-cannon
  (name :initform "Muon energy cannon")
  (tile :initform "gun")
  (ammo :initform =muon-particle=)
  (categories :initform '(:item :weapon :equipment))
  (equip-for :initform '(:center-bay))
  (weight :initform 7000)
  (accuracy :initform (make-stat :base 100))
  (attack-power :initform (make-stat :base 12))
  (attack-cost :initform (make-stat :base 10))
  (energy-cost :initform (make-stat :base 1)))

(define-method change-ammo muon-cannon (ammo)
  (assert (clon:object-p ammo))
  (setf <ammo> ammo))

(define-method fire muon-cannon (direction)
  (if [expend-energy <equipper> [stat-value self :energy-cost]]
      (let ((bullet (clone <ammo>)))
	[>>drop <equipper> bullet]
	[>>impel bullet direction])
      [say <equipper> "Not enough energy to fire!"]))

(define-method step muon-cannon (stepper)
  (when [is-player stepper]
    [>>take stepper :direction :here :category :item]))

;;; Phonic particles

(defcell particle 
  (tile :initform "particle")
  (direction :initform (car (one-of '(:north :south :east :west))))
  (categories :initform '(:actor))
  (clock :initform (random 20)))

(define-method run particle ()
  (decf <clock>)
  (setf <tile> (car (one-of '("particle" "particle2" "particle3"))))
  ;;[play-sample self "particle-sound-1"]
  (if (minusp <clock>) [die self]
      [move self <direction>]))

;;; Phi particles

(defcell phi
  (tile :initform "phi")
  (direction :initform (car (one-of '(:north :northeast :northwest :southeast :southwest :south :east :west))))
  (categories :initform '(:actor))
  (clock :initform (random 20)))

(define-method run phi ()
  (decf <clock>)
  (setf <tile> (car (one-of '("phi" "phi2" "phi3"))))
  ;;[play-sample self "particle-sound-1"]
  (if (minusp <clock>) 
      [die self]
      (progn (percent-of-time 3 [play-sample self (car (one-of '("dtmf1" "dtmf2" "dtmf3")))])
	     [move self <direction>])))

;;; Health powerup

(defcell health
  (name :initform "Repair unit")
  (description :initform "The single-use program REPAIR-1 restores a few hit points when activated.")
  (tile :initform "health")
  (energy-cost :initform 0)
  (call-interval :initform 20)
  (categories :initform '(:item :defun)))

(define-method call health (caller)
  (when [is-player caller]
    [stat-effect caller :hit-points 6]
    [play-sample self "buzzfan"]
    [say caller "Recovered 6 hit points."]
    [expend-item caller]))

;;; Shield

(defcell shield
  (tile :initform "shield")
  (description :initform "Wave shield blocks sound waves.")
  (team :initform :neutral)
  (default-cost :initform (make-stat :base 10))
  (speed :initform (make-stat :base 20))
  (hit-points :initform (make-stat :base 5 :min 0))
  (categories :initform '(:actor :target)))

(define-method hit shield (&optional wave)
  (when [in-category wave :wave]
    [play-sample self "ice"]
    [damage self 1]))

(define-method run shield () nil)

;;; White noise

(defcell noise 
  (tile :initform (car (one-of '("white-noise" "white-noise2" "white-noise3" "white-noise4"))))
  (categories :initform '(:actor))
  (clock :initform (random 20)))

(define-method run noise ()
  (decf <clock>)
  [play-sample self "noise-white"]
  (if (minusp <clock>) [die self]
      [move self (random-direction)]))

;;; Radioactive gas

(defcell gas
  (tile :initform "rad")
  (name :initform "Radioactive Gas")
  (clock :initform 100)
  (categories :initform '(:actor))
  (description :initform "Spreading toxic radioactive gas. Avoid at all costs!"))

(define-method step gas (stepper)
  (when [is-player stepper]
    [damage stepper 5]
    [>>say :narrator "RADIOACTIVE HAZARD!"]))

(define-method run gas ()
  [play-sample self "gas-poof"]
  (decf <clock>)
  (if (> 0 <clock>)
      [die self]
      (progn 
	(do-cells (cell [cells-at *world* <row> <column>])
	  (when [is-player cell]
	    [damage cell 5]
	    [>>say :narrator "RADIOACTIVE HAZARD!"]))
	[move self (random-direction)])))

;;; A melee weapon: the Shock Probe

(defcell shock-probe 
  (name :initform "Shock probe")
  (categories :initform '(:item :weapon :equipment))
  (tile :initform "shock-probe")
  (attack-power :initform (make-stat :base 5))
  (attack-cost :initform (make-stat :base 6))
  (accuracy :initform (make-stat :base 90))
  (stepping :initform t)
  (weight :initform 3000)
  (equip-for :initform '(:robotic-arm :left-hand :right-hand)))

(define-prototype shock-prod (:parent =shock-probe=)
  (name :initform "Shock prod")
  (attack-power :initform (make-stat :base 7))
  (attack-cost :initform (make-stat :base 12))
  (accuracy :initform (make-stat :base 80)))
  
;;; Lepton Seeker Cannon

(defvar *lepton-tiles* '(:north "lepton-north"
		       :south "lepton-south"
		       :east "lepton-east"
		       :west "lepton-west"
		       :northeast "lepton-northeast"
		       :southeast "lepton-southeast"
		       :southwest "lepton-southwest"
		       :northwest "lepton-northwest"))

(defvar *lepton-trail-middle-tiles* '(:north "bullet-trail-middle-thin-north"
			       :south "bullet-trail-middle-thin-south"
			       :east "bullet-trail-middle-thin-east"
			       :west "bullet-trail-middle-thin-west"
			       :northeast "bullet-trail-middle-thin-northeast"
			       :southeast "bullet-trail-middle-thin-southeast"
			       :southwest "bullet-trail-middle-thin-southwest"
			       :northwest "bullet-trail-middle-thin-northwest"))

(defvar *lepton-trail-end-tiles* '(:north "bullet-trail-end-thin-north"
			       :south "bullet-trail-end-thin-south"
			       :east "bullet-trail-end-thin-east"
			       :west "bullet-trail-end-thin-west"
			       :northeast "bullet-trail-end-thin-northeast"
			       :southeast "bullet-trail-end-thin-southeast"
			       :southwest "bullet-trail-end-thin-southwest"
			       :northwest "bullet-trail-end-thin-northwest"))

(defvar *lepton-trail-tile-map* (list *lepton-trail-end-tiles* *lepton-trail-middle-tiles* *lepton-trail-middle-tiles*))

(define-prototype lepton-trail (:parent xe2:=cell=)
  (categories :initform '(:actor))
  (clock :initform 2)
  (speed :initform (make-stat :base 10))
  (default-cost :initform (make-stat :base 10))
  (tile :initform ".gear")
  (direction :initform :north))

(define-method initialize lepton-trail (direction)
  (setf <direction> direction)
  (setf <tile> (getf *lepton-trail-middle-tiles* direction)))

(define-method run lepton-trail ()
  (setf <tile> (getf (nth <clock> *lepton-trail-tile-map*)
		     <direction>))
  [expend-default-action-points self]
  (decf <clock>)
  (when (minusp <clock>)
    [die self]))

(define-prototype lepton-particle (:parent xe2:=cell=)
  (categories :initform '(:actor :target :lepton))
  (speed :initform (make-stat :base 8))
  (seeking :initform :player)
  (team :initform :player)
  (stepping :initform t)
  (hit-damage :initform (make-stat :base 7))
  (default-cost :initform (make-stat :base 2))
  (hit-points :initform (make-stat :base 5))
  (movement-cost :initform (make-stat :base 4))
  (tile :initform "lepton")
  (direction :initform :here)
  (clock :initform 10))

(define-method find-target lepton-particle ()
  (let ((target [category-in-direction-p *world* 
					 <row> <column> <direction>
					 '(:obstacle :target)]))
    (if target
	(unless (same-team self target)	
	  (dotimes (n 3)
	    [drop target (clone =explosion=)])
	  [damage target [stat-value self :hit-damage]]
	  [play-sample target "serve"]
	  (labels ((do-circle (image)
		     (prog1 t
		       (multiple-value-bind (x y) 
			   [screen-coordinates self]
			 (let ((x0 (+ x 8))
			       (y0 (+ y 8)))
			   (draw-circle x0 y0 40 :destination image)
			   (draw-circle x0 y0 35 :destination image))))))
	    [>>add-overlay :viewport #'do-circle])
	  [die self])
	(progn 
	  [drop self (clone =lepton-trail= <direction>)]
	  [move self <direction>]))))

(define-method update-tile lepton-particle ()
  (setf <tile> (getf *lepton-tiles* <direction>)))
  
(define-method seek-direction lepton-particle ()
  (ecase <seeking>
    (:player [direction-to-player *world* row column])
    (:enemy (let (enemies)
	      (labels ((find-enemies (r c)
			 (let ((enemy [enemy-at-p *world* r c]))
			   (prog1 nil
			     (when enemy
			       (when [can-see self enemy :barrier]
				 (push enemy enemies)))))))
		(trace-rectangle #'find-enemies (- <row> 3) (- <column> 3) 7 7 :fill))
	      (if enemies
		  (multiple-value-bind (row column) [grid-coordinates (car enemies)]
		    (direction-to <row> <column> row column))
		  <direction>)))))
		
(define-method run lepton-particle ()
  [update-tile self]
  (clon:with-field-values (row column) self
    (let* ((world *world*)
	   (direction [seek-direction self]))
      (setf <direction> direction)
      [find-target self])
    (decf <clock>)
    (when (and (zerop <clock>) 
	       (not [in-category self :dead]))
      [>>die self])))

(define-method seek lepton-particle (key)
  (setf <seeking> key))

(define-method damage lepton-particle (points)
  (declare (ignore points))
  [drop self (clone =sparkle=)]
  [die self])
      
(define-method impel lepton-particle (direction)
  (assert (member direction *compass-directions*))
  (setf <direction> direction)
  ;; don't hit the player
  [find-target self])

(define-prototype lepton-cannon (:parent xe2:=cell=)
  (name :initform "Xiong Les Fleurs Lepton(TM) energy cannon")
  (tile :initform "lepton-cannon")
  (categories :initform '(:item :weapon :equipment))
  (equip-for :initform '(:robotic-arm))
  (weight :initform 14000)
  (accuracy :initform (make-stat :base 60))
  (attack-power :initform (make-stat :base 16))
  (attack-cost :initform (make-stat :base 25))
  (energy-cost :initform (make-stat :base 32)))

(define-method fire lepton-cannon (direction)
  (if [expend-energy <equipper> [stat-value self :energy-cost]]
      (let ((lepton (clone =lepton-particle=)))
	[play-sample <equipper> "bloup"]
	[drop <equipper> lepton]
	[impel lepton direction]
	[expend-action-points <equipper> [stat-value self :attack-cost]]
      (message "Not enough energy to fire."))))

;;; Lepton weapon for player

(defcell lepton-defun
  (name :initform "Lepton homing missile")
  (description :initform 
"The LEPTON program fires a strong homing missile.")
  (tile :initform "lepton-defun")
  (energy-cost :initform 5)
  (call-interval :initform 20)
  (categories :initform '(:item :target :defun)))

(define-method call lepton-defun (caller)
  (clon:with-field-values (direction row column) caller
    (let ((lepton (clone =lepton-particle=)))
      [play-sample caller "bloup"]
      [drop caller lepton]
      [seek lepton :enemy]
      [impel lepton direction])))

;;; There are also energy tanks for replenishing ammo.

(defcell energy 
  (tile :initform "energy")
  (name :initform "Energy refill")
  (description :initform "Refills part of your energy store.")
  (energy-cost :initform 0)
  (call-interval :initform 20)
  (categories :initform '(:item :target :defun)))

(define-method call energy (caller)
  [play-sample caller "whoop"]
  [stat-effect caller :energy 20]
  [expend-item caller])

(defcell energy-tank
  (tile :initform "energy-max-up")
  (name :initform "Energy Tank")
  (description :initform "Increases maximum energy store by 15.")
  (energy-cost :initform 0)
  (call-interval :initform 20)
  (categories :initform '(:item :target :defun)))

(define-method call energy-tank (caller)
  [play-sample caller "fanfare"]
  [stat-effect caller :energy 15 :max]
  [>>narrateln :narrator "Increased max energy by 15!" :foreground ".yellow" :background ".blue"]
  [expend-item caller])

;;; An exploding missile.

(defvar *missile-trail-tile-map* (list *lepton-trail-end-tiles* *lepton-trail-middle-tiles* *lepton-trail-middle-tiles*))

(defvar *missile-tiles* '(:north "missile-north"
		       :south "missile-south"
		       :east "missile-east"
		       :west "missile-west"
		       :northeast "missile-northeast"
		       :southeast "missile-southeast"
		       :southwest "missile-southwest"
		       :northwest "missile-northwest"))

(define-prototype missile (:parent =lepton-particle=)
  (speed :initform (make-stat :base 25))
  (hit-damage :initform (make-stat :base 10))
  (hit-points :initform (make-stat :base 10))
  (tile :initform "missile-north")
  (clock :initform 20))

(define-method update-tile missile ()
  (setf <tile> (or (getf *missile-tiles* <direction>)
		   "missile-north")))

(define-method die missile ()
  [drop self (clone =explosion=)]
  [parent>>die self])

;;; Multi-warhead missile

(defvar *multi-missile-tiles* '(:north "multi-missile-north"
		       :south "multi-missile-south"
		       :east "multi-missile-east"
		       :west "multi-missile-west"
		       :northeast "multi-missile-northeast"
		       :southeast "multi-missile-southeast"
		       :southwest "multi-missile-southwest"
		       :northwest "multi-missile-northwest"))

(define-prototype multi-missile (:parent =missile=)
  (tile :initform "multi-missile-north")
  (clock :initform 12)
  (hit-damage :initform (make-stat :base 18))
  (hit-points :initform (make-stat :base 20)))

(define-method update-tile multi-missile ()
  (setf <tile> (or (getf *multi-missile-tiles* <direction>)
		   "multi-missile-north")))

(define-method run multi-missile ()
  [update-tile self]
  (if (or (= 0 <clock>)
	  (> 7 [distance-to-player self]))
      ;; release warheads
      (progn 
	(dolist (dir (list :northeast :southeast :northwest :southwest))
	  (multiple-value-bind (r c) 
	      (step-in-direction <row> <column> dir)
	    [drop-cell *world* (clone =missile=) r c]))
	[die self])
      ;; move toward player
      (progn (decf <clock>)
	     [parent>>run self])))

(define-method die multi-missile ()
  [drop self (clone =flash=)]
  [parent>>die self])
  
;;; Missile launchers

(define-prototype missile-launcher (:parent =lepton-cannon=)
  (ammo :initform =missile=)
  (attack-cost :initform (make-stat :base 20)))

(define-method fire missile-launcher (direction)
  (let ((missile (clone <ammo>)))
    [play-sample <equipper> "bloup"]
    [>>drop <equipper> missile]
    [>>impel missile direction]
    [expend-action-points <equipper> [stat-value self :attack-cost]]))

(define-prototype multi-missile-launcher (:parent =missile-launcher=)
  (ammo :initform =multi-missile=)
  (attack-cost :initform (make-stat :base 80)))
#+end_src

* Enemies						:Enemies:

* Setting 						  :Story:

It's 2061. If only there were enough endurium!

It's been known for decades that Humanity's reach within the Milky Way
is limited only by the supply of endurium, its rare and precious
fuel. The energy crises of C.E. 2021 and C.E. 2027-2031 caused global
economic, social, and environmental disruption, and with this
disorganization came the concentration of wealth and power in the
hands of the government and corporate elites.

Early attempts at control and regulation of endurium met with initial
success. The space-faring nations---Russia, China, India, Japan,
Brazil, and the United States---along with the ESA (European Space
Agency), could quite naturally claim endurium for themselves. But
economies of scale and espionage in spaceflight technology eventually
brought smaller deposits and endurium dust streams throughout the
interstellar neighborhood within the reach of multinational
corporations and various non-state actors. The largest of these formed
what they called a "sovereign", open, and successful market in
endurium, spaceflight technology, and various otherwise-controlled
materials. The split between the Spacefaring Nations on the one hand,
and the United Nations on the other, threatens to break into
full-scale interstellar war; as Earth's environment continues to
decay, the demand for endurium has reached a critical point.

* Plot

** Prologue

A new high-powered telescope operated by Xiomacs Corporation detects a
pattern of gas streamers radiating high in the ultraviolet, within a
cavernous void in galactic space. Subsequent observations show that
the streamers are emitted from a string of black holes. The
scientists, seeing the pattern's obviously artificial nature, guess at
a propulsion method being used to drive a spacecraft, and begin to
look for something at the trail's leading edge. A year later one of
the flare-ups is observed, and the calculations fall into place: the
source of the black holes is an object about as massive as Jupiter,
but much smaller and far more dense. And it has been accelerating for
1.2 billion years by riding on streams of gas being ejected from the
black holes at relativistic speeds. It is given the name DVO1, for
Deep Void Object 1.

*** DONE Opening movie!
CLOSED: [2010-07-13 Tue 05:24]
**** TODO 3 cards progressive reveal of 3 short paragraphs, black screen white text.

 It's A.D. 2061. Earth's resources are nearly exhausted. The
 government/corporation complex elites now control humanity's only
 remaining energy source, the rare material Endurium.
 
**** TODO "freedom 0: the freedom to survive" propaganda poster 
**** TODO false-color gas streamer images and fake data
**** TODO slideshow of blurry diagrams filtered through xanalogtv

** Episode 1

A mysterious Xiomacs operative named Brennan stays in the Void Rider
as mission commander, while you take off in an exosuit. Your mission
is to rendezvous with the DVO and make initial discoveries.

*** 1.1: Acquire cloud data

The cloud obscuring the DVO is meant as a shield to protect it from
the ultraviolet radiation caused by the black holes that propel it
across the universe. Drop scanning devices at each of 3 nav points
surrounding the cloud to complete this mission.

**** DONE [#C] Create basic Defgame macro and use it for voidmission
CLOSED: [2010-07-13 Tue 05:24]
**** TODO [#B] Occasional flashes of background moving cloud fragments in the dark
**** TODO [#B] Tiny thunder particle/sparks whenever cloud fragments glow
**** TODO [#B] Neon cloud pieces are irregular mostly-transparent pixel pngs that float along one another
**** TODO [#A] Mostly empty space where you start at bottom, nebula cloud to north
**** TODO [#A] Limited sight distance
**** TODO [#A] Nav points 
**** TODO [#A] Scanners
**** TODO [#A] Macrovirii
**** TODO [#B] Brainstorm dead simple log ui system
**** TODO [#B] Dialogue and messages

A strange transmission burst is received after the 1st scanning device
is placed. The game's first enemies strike after the 2nd scanning
device is placed.

** TODO Burst sound and text

The measurement data enable plotting a path through the cloud to the
DVO itself.

*** 1.2: Enter DVO orbit

**** TODO Corridor level
**** TODO Black space with DVO visible at one edge as a curved planet surface (NASA)
**** TODO Xianghua cruiser sprite

Long, narrow northward corridor with cloud walls and enemies.

Fight your way through the cloud and enter orbit around the DVO. You
discover a large Xianghua Industries cruiser already in orbit, a dead
hulk with no energy or life signs. At this point it becomes obvious
that you are not the first human to visit the DVO, and that at least
one other Corporation has reached orbit and possibly the DVO itself.

*** 1.3: Retrieve memory card

**** TODO High-tech interior

You must restore power to the Xianghua cruiser and retrieve a memory
card with a copy of the map. Once power is restored, security gates
will activate, and you must throw switches to turn them off. Once you
get the memory card, this is combined with new information (ancient
texts) possessed by Xiomacs. This helps Brennan choose an appropriate
landing site on the DVO.

** Episode 2

*** 2.1 Investigate landing site

You find yourself in a windswept ocean of grey sands with outcroppings
of black glass. This more ambient level involves radar searching and
some digging with charges, as well as a climactic boss encounter with
a big sprite :)

You find some supplies and a high-bandwidth transmitter at the
scattered camp sites of the previous expedition's landing.

After defeating this boss you may enter the DVO itself. 

*** 2.2 Investigate DVO origins and purpose

This level involves some tricky enemies and some tone-based puzzles,
giving the first hint at the Ancients' mindset and language. Square,
sine, and saw.

You discover the probe carries the last embryos and the encoded
knowledge of a dying species. The probe is automatically carrying out
its mission to escape a replicating, matter-rearranging mechanical
menace known as the Black Metal. The goal is for the probe to tear a
portion of the universe away from ours at the moment of the Heat
Death, so that the new universe and the old will be absolutely
causally unconnected; only in this way can the Black Metal be escaped,
and their race renewed. 

The Ancients calculated that the Black Metal would grow forever,
dominating matter and space without limit, and therefore all
information and energy. It would be the extinction of all life, and
eventually of all phenomena; a true Heat Death. (The metric expansion
of space and the DVO's great speed ensure that any pursuing Black
Metal objects could never reach the DVO.)

*** 2.3 Return to surface

You receive an urgent message from Brennan but he is cut off in
mid-sentence, something about getting back to the ship. When you reach
the surface, fighting many enemies along the way, the computer decides
to speak, and tells you that you've come 31 million years in the
future, and Brennan (and the rest of Humanity) are long dead.

** Episode 3

*** 3.1 Return to Void Rider

The computer explains that it just awoke, and cannot control its
malfunctioning defense systems (i.e. the enemies you have encountered
up until this point.) Furthermore, the entire mission is in danger,
because a tiny capsule of dormant Black Metal had been secretly
installed aboard the Void Rider, still orbiting the DVO and now slowly
being transformed. In fact the whole mission is a plot to take over
all the DVO's, a plot organized and executed by the Black Metal
itself, who manipulated Xiomacs Corporation through various human
contact personalities. By contaminating the DVOs with Black Metal, the
substance could survive and flourish in the new "tear-away" universes,
and enlarge its dominion to the total range of possible universes; a
dark consciousness that has absorbed literally Everything. The only
way to destroy the Void Rider is to steer it into the path of one of
the black holes as it is ejected from the DVO.

*** 3.2 Reprogram flight computer

Go aboard the Void Rider and reprogram the flight computer so that it
flies into the path of the next black hole. Along the way one must
find two encryption keys to unlock doors. Here one discovers documents
and logs relating to the failed mission and what happened to Brennan
and the Void Rider after you disappeared. You learn that Brennan may
be alive, in stasis somewhere on the DVO. Furthermore the cosmological
speculations of another crew member hint at manifold
possibilities. After Brennan left for the DVO, the remaining crew ran
out of supplies and starved. But before this happened, there were
glimmers of a way back in time; by traveling in a shuttle along the
trail of black holes left by the DVO, one could reverse time and
travel to the point and time of the object's origin.

*** 3.3 Restore engine power

Reactivate the Void Rider's engines so that the flight computer can
steer it into the path of the black hole, and then escape back to the
DVO.

The DVO fires a black hole, and the Void Rider is destroyed
utterly. 

*** 3.4 Investigate stasis chamber 

The computer gets unusual levels of electromagnetic noise in one spot
on the surface; you are led to a stasis chamber where you discover
Brennan frozen in time. After un-freezing he takes the Black Metal
capsule from his pocket and reveals that the Black Capsule contains
sufficient Black Metal to dominate any new universe formed by the DVO,
and that the hive mind has promised long life and vast powers to those
who advance its cause. After a climactic battle with Brennan, the
Black Capsule falls into the player's hands.

*** 3.5 Destroy black capsule

You take the black capsule to the propulsion lab, where it is disposed
of in a black hole before ejection.

The computer explains that in order to travel back to your own epoch,
you need a much longer trail of black holes to accelerate along. The
computer calculates that you'd need to wait many billions of years, so
you enter a stasis chamber and awaken sometime just before the Heat
Death, into a nearly featureless cosmos. The DVO has decayed
significantly and seems barely able to continue its mission. The
computer itself is tired of consciousness.

You enter a stasis chamber and launch yourself back along the trail of
black holes, slingshotting from one event horizon to another, and
arrive in an unknown area.


